/**
  * Protocol between cores (peers).
  * Version : 1
  * All string are encoded in UTF-8.
  */

import "common.proto";

package Protos.Core;

/***** Multicast UDP messages. *****/
// Im alive.
// This message is sent periodically to all other peers.
// It send an array of hash chunks to know which one has which chunk.
// If a peer owns one or more chunk corresponding to the given hashes then it
// will reply with a 'ChunksOwned' message.
// These hashes can come from different files.
// a -> all
// id : 0x01
message IMAlive {
   required uint32 version = 1; // The version of the protocol used.
   required uint32 port = 2; // The port listened by the core.
   required string nick = 3;
   required uint64 amount = 4; // [byte] Amount of sharing.
   
   optional uint64 tag = 5; // A random number, all results must repeat this number.
   repeated Common.Hash chunk = 6; // Can be empty.
}
// This message is only sent if some chunks are requested.
// Return an array with a bool value for each
// given chunks. 'true' means "I have this chunk".
// Not sent if the peer doesn't own any chunk.
// all -> a
// id : 0x02
message ChunksOwned {
   required uint64 tag = 1; // The repeated number.
   repeated bool chunk_state = 2 [packed=true]; // The array size must have the same size of HaveChunks.chunks.
}

// a -> all
// id : 0x11
message ChatMessage {
   required string message = 1;
}

// Searching a file or a directory.
// See http://dev.euphorik.ch/wiki/pmp/Algorithms#Searching for more details.
// a -> all
// id : 0x21
message Find {
   required uint64 tag = 1; // A tag to identify the search. All answers must have the same tag.
   required string pattern = 2;
}
// Results.
// The size of this message must fit in a UDP packet so it must not exeed 65'507 bytes.
// Number of average entry in a result (we don't take in account the overhead of protobuff) :
//  n = 65507 / (level + averagePathFilenameSize + Size + averageHashNb * 20)
//  n = 65507 / (4 + 100 + 8 + 20 * 20) = 127 entries.
// Many of message can be sent by a peer for a given search. The core will only accept answers
// for a limited duration. For example 10 seconds.
// all -> a
// id : 0x22
// Common.FindResult (see common.proto)


/***** Unicast TCP Messages. *****/
// Browsing.
// a -> b
// id : 0x31
message GetEntries {
   optional Common.Entry dir = 1; // If the directories are omitted the shared directories (roots) are return.
}
// b -> a
// id : 0x32
message GetEntriesResult {
   repeated Common.Entry entry = 1;
}

// Get hashes.
// If a peer want to start a queued download but doesn't know its hashes
// it will ask the hashes to the source peer.
// If 'b' doesn't have the hashes but have the file
// the hashes will be computed on the fly. Thus this request
// can be a bit long (~20s).
// a -> b
// id : 0x41
message GetHashes {
   required Common.Entry file = 1; // Must have the field shared_dir set.
}
// b -> a
// id : 0x42
message GetHashesResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // 'b' doesn't have the requested entry.
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
   required uint32 nb_hash = 2;
}
// For each hash, this message is sent. Only if GetHashesResult.status == OK.
// b -> a
// id = 0x43
// Common.Hash
// or (only once)
// id = 0x44
// Common.Error

// Download.
// a -> b
// id : 0x51
message GetChunk {
   required Common.Hash chunk = 1;
   required uint32 offset = 2; // [byte] Relative to the beginning of the chunk.
}
// b -> a
// id : 0x52
message GetChunkResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // 'b' doesn't have this chunk.
      ALREADY_DOWNLOADING = 2; // If 'a' is already downloading a chunk from 'b'.
      TOO_MANY_CONNECTIONS = 3;
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
}
// b -> a : stream of data..
