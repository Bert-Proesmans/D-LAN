/**
  * Protocol between core and GUI.
  * When a command is sent to the core, one or more responds will be sent back,
  * there cannot be other message like 'event message' between theses messages.
  * Version : 1
  * All string are encoded in UTF-8.
  */

import "common.proto";
import "core_settings.proto";

package Protos.GUI;

message Peer {
   optional Common.Hash peer_id = 1;
   optional string nick = 2;
   optional uint64 sharing_amount = 3; // [byte].
}
   
message CoreSettings {
   required Peer myself = 1;
   repeated string shared_directory = 2;
   repeated string destination_directory = 3;
}

/***** Core state *****/
// Core -> GUI
// The state is sent periodically to the GUI (each second for example)
// or right after a GUI command.
// The size of this message should be lesser than 63kB to fit in one IP packet.
// id : 0x01
message State {
   // A download can be a file or a directory.
   message Download {
      enum Status {
         QUEUED = 0x1;
         INITIALIZING = 0x2;
         DOWNLOADING = 0x3;
         COMPLETE = 0x4;
         PAUSED = 0x5;
         
         UNKNOWN_PEER = 0x10; // When the peer is online the download will (re)start automatically.
         ENTRY_NOT_FOUND = 0x11; // When the entry is found the download will start automatically
         NO_SOURCE = 0x12; // When a new source is available the download will start automatically.
         
         // All the following status will pause the download.
         NO_SHARED_DIRECTORY_TO_WRITE = 0x20;
         NO_ENOUGH_FREE_SPACE = 0x21;
         UNABLE_TO_CREATE_THE_FILE = 0x22;
         UNABLE_TO_RETRIEVE_THE_HASHES = 0x23;
      }
      required uint64 id = 1;
      required Common.Entry entry = 2; // Can be remote or local. When we know all the hashes and the local file exists (.unfinished) the entry becomes local, otherwise the entry is a remote one.
      required Status status = 3;
      required uint32 progress = 4; // 0 to 100.
      repeated Common.Hash peer_id = 5;
   }
   message Upload {
      required uint64 id = 1;
      required Common.Entry file = 2;
      required uint32 current_part = 3;
      required uint32 nb_part = 4;
      required uint32 progress = 5; // 0 to 100.
      required Common.Hash peer_id = 6;
   }
   message Stats {
      enum CacheStatus {
         SCANNING_IN_PROGRESS = 0; // 1st pass : grab all file/dir names and their size and index it.
         HASHING_IN_PROGRESS = 1;
         UP_TO_DATE = 2;
      }
      required CacheStatus cache_status = 1;
      required uint32 progress = 2; // 0 to 100
      required uint32 download_rate = 3; // [byte/s].
      required uint32 upload_rate = 4; // [byte/s].
   }
   
   repeated Peer peer = 1;
   
   repeated Download download = 2;
   repeated Upload upload = 3;
   
   optional CoreSettings settings = 4;
   optional Stats stats = 5;
}

/***** Events *****/
// Core -> GUI
// id : 0x11
message EventChatMessage {
   required Common.Hash peer_id = 1;
   required string message = 2;
}

// Core -> GUI
// id : 0x12
message EventLogMessage {
   enum Severity {
      SV_FATAL_ERROR = 0x01;
      SV_ERROR = 0x02;
      SV_WARNING = 0x04; // Send to the GUI but should not be shown to the user.
      SV_DEBUG = 0x08; // Never send to the GUI, there are only logged in the core log file.
      SV_END_USER = 0x10;
      SV_UNKNOWN = 0x20;
   }
   
   required uint64 time = 1; // In [ms] since Epoch.
   required Severity severity = 2;
   required string message = 3;
   
   // Only in debug mode. (not used at all for the moment).
   // optional string component = 4;
}

/***** Commands. *****/
// Authentication.
// Must be send for non-local connection as the first message.
// All other messages can't be sent or received without a proper authentication.
// Authentication tries from a local connection will be ignored by the core.
// GUI -> Core
// id : 0x21
message Authentication {
   required Common.Hash password = 1; // Salt should be added.
}
// Core -> GUI
// If BAD_PASSWORD the core should wait a bit before sending the result (for example 1s) to avoid dictionary attack.
// id : 0x22
message AuthenticationResult {
   enum Status {
      OK = 0x01;
      BAD_PASSWORD = 0x02;
      ERROR = 0x03;
   }
   required Status status = 1;
}

// Set the settings
// Peer.peer_id and Peer.sharing_amount are ignored.
// GUI -> Core
// id : 0x31
// Message 'CoreSettings'

// GUI -> Core
// id : 0x41
message Search  {
   required string pattern = 2;
}
// Core -> GUI (directly)
// id : 0x42
message Tag  {
   required uint64 tag = 2;
}
// Core -> GUI (deffered)
// This message is sent for each UDP datagram received.
// id : 0x43
// Common.FindResult

// GUI -> Core
// id : 0x51
message Browse {
   required Common.Hash peer_id = 1;
   optional Common.Entry dir = 2;
}
// Core -> GUI (directly)
// id : 0x52
// Tag
// Core -> GUI (deffered)
// id : 0x53
message BrowseResult {
   required Common.Entries entries = 1;
   required uint64 tag = 2;
}

// GUI -> Core
// Remove one or several download from the queue. If this download
// is not finished the unfinished file is removed.
// id : 0x61
message CancelDownloads {
   repeated uint64 id = 1;
}

// GUI -> Core
// Tell the core to move one or more downloads in the list right before or after a given download.
// 'id_ref' must exist.
// The order of the moved downloads are kept unchanged.
// For example : id_ref = 21, move_before = true, id = [16, 18]
// Initial list : [34, 21, 18, 54, 16]
// After the operation : [34, 18, 16, 21, 54]
// id : 0x71
message MoveDownloads {
   required uint64 id_ref = 1;
   optional bool move_before = 2 [default = true];
   repeated uint64 id_to_move = 3;
}

// GUI -> Core
// Says to the core to download a file or a directory.
// id : 0x81
message Download {
   required Common.Hash peer_id = 1; // From where the file/dir is.
   required Common.Entry entry = 2;
}

// GUI -> Core
// Send a chat message to everyone.
// id : 0x91
message ChatMessage {
   required string message = 1;
}

// GUI -> Core
// Ask to receive a new state.
// This message doesn't have a body.
// id : 0xa1
