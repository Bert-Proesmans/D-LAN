/**
  * Some common messages.
  * All string are encoded in UTF-8.
  */

package Protos.Common;

message Null {
}

message Error {
   optional string message = 1;
}

message Language {
   required string lang = 1; // ISO-639 (two letters)
   optional string country = 2; // ISO-3166
}

// For identify a chunk or a user.
message Hash {
   optional bytes hash = 1; // 20 bytes. If it doesn't exist the hash is null.
}

message IP {
   enum Type {
      IPv4 = 0;
      IPv6 = 1;
   }
   required Type type = 1;
   required bytes ip = 2; // type == IPv4: 4 bytes. type == IPv6: 16 bytes. Big endian.
}

// A shared entry matches an existing handle, thus it's optional to have the complete path to it.
message SharedEntry {
   required Hash id = 1; // Identify a shared entry.

   // A name to identify the shared entry by human.
   // It may correspond to the name of the shared entry itself (directory or file name).
   // It may be used when creating the directories of a new downloading file.
   optional string shared_name = 2;

   optional string path = 3; // A dir must end with a "/" otherwise it's a file.
}

// Used for a directory or a file.
message Entry {
   enum Type {
      FILE = 0;
      DIR = 1;
   }
   required Type type = 1;

   // Relative path from the sharing entry. For example : "/Videos/My cat/".
   // A root directory or file has a one slash : "/".
   // A shared directory or a shared file has an empty path.
   required string path = 2;

   required string name = 3; // Directory name or file name. For example: "MyLOLCat.avi".
   required uint64 size = 4; // [bytes]. For the directory it's the sum of all sub-items.
   
   optional SharedEntry shared_entry = 5; // The shared entry of the entry.
   optional bool exists = 6 [default = true]; // An entry may not yet be created.

   // Only for DIR type.
   optional bool is_empty = 7 [default = true]; // Warning: a directory can be not empty and has a size of 0.

   // Only for FILE type:
   // optional string mime_type = 9; // The mime type of the file. TODO: uncomment when #243 is implemented.
   repeated Hash chunk = 8; // The number of chunk must always correspond to the size of the file. Unknown chunks are empty.
}

message Entries
{
   repeated Common.Entry entry = 1;
}

message FindPattern {
   required string pattern = 2;
   optional uint64 min_size = 3; // [B]. 0 means there is no minimum size.
   optional uint64 max_size = 4; // [B]. 0 means there is no maximum size.
   repeated string extension_filter = 5; // Only files that match one of the given extension will be returned.
   enum Category {
      FILE_DIR = 0;
      FILE = 1;
      DIR = 2;
   }
   optional Category category = 6 [default = FILE_DIR];
}

// A result following a search.
// Entries may not be sorted in any particular way.
// See 'Core.Find' and 'GUI.Search' for more information.
message FindResult {
   message EntryLevel {
      required uint32 level = 1;
      required Entry entry = 2; // The entry must have the field 'shared_dir'.
   }
   required uint64 tag = 1;
   repeated EntryLevel entry = 2;
   optional Common.Hash peer_id = 3;
}

// 'id' is randomly generated for each message.
message ChatMessage {
   required uint64 id = 1;
   required string message = 2;
   optional Common.Hash peer_id = 3;
   optional uint64 time = 4; // In [ms] since Epoch.
   optional string peer_nick = 5;
   optional string chat_room = 6;
   repeated Common.Hash peer_ids_answer = 7;
}

// All messages must belong to the same chat room (or from no room if they are from the main chat).
// The messages are always sorted from oldest to youngest.
message ChatMessages {
   repeated ChatMessage message = 1;
}

message Interface {
   message Address {
      enum Protocol {
         IPv4 = 1;
         IPv6 = 2;
      }
      required string address = 1;
      required Protocol protocol = 2;
      required bool listened = 3;
   }
   required uint32 id = 1;
   required string name = 2;
   repeated Address address = 3;
   optional bool isUp = 4;
}
