/**
  * Protocol between cores (peers).
  * Version : 1
  * All string are encoded in UTF-8.
  */

package Network;

/***** Common types. *****/
// For identify a chunk or a user.
message Hash {
   required bytes hash = 1; // 20 bytes
}

// Used for a directory or a file.
message Entry {
   required string path = 1; // Absolute path. For example : "D:\My Videos\My cat"
   required string name = 2; // Directory name or file name. For example : "MyLOLCat.avi"
   required uint64 size = 3; // Bytes.
}
message DirEntry {
   required Entry dir = 1;
}
message FileEntry {
   required Entry file = 1;
   repeated Hash chunks = 2; // No chunk means that the peer doesn't know the hashes.
}

/***** Multicast UDP messages. *****/
// Have chunks ?
// This message is sent periodically to all other peers.
// It send an array of hashe chunks. These hases can come
// from different files.
// This message is also used to know the other peers.
// a -> all
message HaveChunks {
   required uint32 version = 1; // The version of the protocol used.
   required string name = 2;
   required uint64 amount = 3; // Amount of sharing in bytes.
   repeated Hash chunks = 4; // Can be empty.
}
// This message is only sent if some chunks are requested.
// Return an array with a bool value for each
// given chunks. 'true' means "I have this chunk".
// all -> a
message HaveChunksResult {
   repeated bool chunkStates = 2; // The array size must have the same size of HaveChunks.chunks.
}

// a -> all
message ChatMessage {
   required string message = 2;
}

/***** Unicast TCP Messages. *****/
// Searching a file or a directory.
// a -> b
message Find {
   required string pattern = 1;
}
// b -> a
message FindResult {
   repeated DirEntry dirs = 1;
   repeated FileEntry files = 2;
}

// Get hashes.
// If a peer want to start a queued download but doesn't know its hashes
// it will ask the hashes to the source peer.
// If 'b' doesn't have the hashes but have the file
// the hashes will be computed on the fly. Thus this request
// can be a bit long (~10s).
// a -> b
message GetHashes {
   required Entry file = 1;
}
// b -> a
message GetHashesResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // 'b' doesn't have this entry.
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
   repeated Hash chunks = 2;
}

// Download.
// a -> b
message GetChunk {
   required Hash chunk = 1;
   required uint32 offset = 2; // Relative to the beginning of the chunk.
}
// b -> a
message GetChunkResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // 'b' doesn't have this chunk.
      ALREADY_DOWNLOADING = 2; // If 'a' is already downloading a chunk from 'b'.
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
}
// b -> a : stream of data..

// Browsing.
// a -> b
message GetEntries {
   required Entry directory = 1;
}
// b -> a
message GetEntriesResult {
   repeated DirEntry dirs = 1;
   repeated FileEntry files = 2;
}
