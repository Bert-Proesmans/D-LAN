package Network;

// All string are encoded in UTF-8

// a -> all
message IMAlive {
   required bytes id = 1; // Sha1 peer ID
   required string name = 2;
   required uint32 version = 3; // the version of the protocol used.
}

// a -> all
message ChatMessage {
   required bytes id = 1; // peer ID
   required string message = 2;
}

// Common types.
message Chunk {
   required bytes hash = 1; // 20 bytes
}
// can be a directory or a file
message Entry {
   required string path = 1;
   required string name = 2; // directory name or file name
   required uint64 size = 3; // bytes
}

// Searching.
// a -> b
message Find {
   required string pattern = 1;
}
// b -> a
message FindResult {
   message DirEntry {
      required Entry dir;
   }
   message FileEntry {
      required Entry file;
      repeated Chunk chunks = 4; // No chunk means that 'b' doesn't know the hashes.
   }
   repeated DirEntry dirs = 1;
   repeated FileEntry files = 2;
}

// Get hash.
// If a peer want to start a queued download but doesn't know its hashes
// it will ask the hashes to the source peer.
// If 'b' doesn't have the hashes but have the file
// the hashes will be computed on the fly. Thus this request
// can be a bit long (~10s).
// a -> b
message GetHashes {
   required Entry file = 1;
}
// b -> a
message GetHashesResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // b doesn't have this entry
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
   repeated Chunk chunks = 2;
}

// Download.
// a -> b
message GetChunk {
   required Chunk chunk = 1;
}
// b -> a
message GetChunkResult {
   enum Status {
      OK = 0;
      DONT_HAVE = 1; // b doesn't have this chunk
      ALREADY_DOWNLOADING = 2; // if a is already downloading a chunk from b
      ERROR_UNKNOWN = 255;
   }
   required Status status = 1;
}
// b -> a : stream of data..

// Have chunks ?
// a -> b
message HaveChunks {
   repeated Chunk chunks = 1;
}
// b -> a
message HaveChunksResult {
   repeated bool chunkStates = 1;
}

// Browsing.
// a -> b
message GetEntries {
   required string path = 1;
}
// b -> a
message GetEntriesResult {
   message DirEntry {
      required string dirname = 1;
      required uint64 size = 2; // bytes
   }
   message FileEntry {
      required string filename = 1;
      required uint64 size = 2; // bytes
      repeated Chunk chunks = 3;
   }
}